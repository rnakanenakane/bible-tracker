CREATE TABLE tb_usuarios (
    id SERIAL PRIMARY KEY,
    nome TEXT NOT NULL UNIQUE,
    created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE tb_planos (
    id SERIAL PRIMARY KEY,
    nome TEXT NOT NULL UNIQUE,
    created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE tb_livros (
    id SERIAL PRIMARY KEY,
    nome TEXT NOT NULL UNIQUE,
    created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE tb_plano_entradas (
    id SERIAL PRIMARY KEY,
    plano_id INTEGER NOT NULL REFERENCES tb_planos(id),
    data_leitura DATE NOT NULL,
    id_livro INTEGER NOT NULL REFERENCES tb_livros(id),
    capitulos TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE tb_leituras (
    id SERIAL PRIMARY KEY,
    usuario_id INTEGER NOT NULL REFERENCES tb_usuarios(id),
    plano_id INTEGER NOT NULL REFERENCES tb_planos(id),
    id_livro INTEGER NOT NULL REFERENCES tb_livros(id),
    capitulo INTEGER NOT NULL,
    created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE tb_perguntas (
    id SERIAL PRIMARY KEY,
    pergunta_texto TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE tb_respostas (
    id SERIAL PRIMARY KEY,
    pergunta_id INTEGER NOT NULL REFERENCES tb_perguntas(id) ON DELETE CASCADE,
    usuario_id INTEGER NOT NULL REFERENCES tb_usuarios(id),
    resposta_texto TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT now()
);


CREATE TABLE public.tb_livros_concluidos (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  usuario_id BIGINT NOT NULL REFERENCES public.tb_usuarios(id) ON DELETE CASCADE,
  plano_id BIGINT NOT NULL REFERENCES public.tb_planos(id) ON DELETE CASCADE,
  id_livro BIGINT NOT NULL REFERENCES public.tb_livros(id) ON DELETE CASCADE,
  CONSTRAINT tb_livros_concluidos_unique_entry UNIQUE (usuario_id, plano_id, id_livro)
);

COMMENT ON TABLE public.tb_livros_concluidos IS 'Armazena registros de conclusão de livros por usuários para otimizar o carregamento do dashboard.';

ALTER TABLE public.tb_livros_concluidos ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Permitir leitura para usuários autenticados"
ON public.tb_livros_concluidos
FOR SELECT
TO authenticated
USING (true);


-- Helper function to expand chapter strings like '1-3' into a set of numbers.
-- This is the SQL equivalent of the Python utility function.
CREATE OR REPLACE FUNCTION expand_capitulos(str_caps TEXT)
RETURNS SETOF INT AS $$
DECLARE
    start_val INT;
    end_val INT;
BEGIN
    IF str_caps LIKE '%-%' THEN
        -- Handles ranges like '10-12'
        start_val := split_part(str_caps, '-', 1)::INT;
        end_val := split_part(str_caps, '-', 2)::INT;
        RETURN QUERY SELECT generate_series(start_val, end_val);
    ELSE
        -- Handles single numbers like '5'
        RETURN QUERY SELECT str_caps::INT;
    END IF;
EXCEPTION WHEN others THEN
    -- If conversion fails for any reason, return an empty set.
    RETURN;
END;
$$ LANGUAGE plpgsql IMMUTABLE;



CREATE OR REPLACE FUNCTION public.handle_book_completion_check(
    p_usuario_id BIGINT,
    p_plano_id BIGINT,
    p_livro_id BIGINT
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    target_chapters_count INT;
    read_chapters_count INT;
    already_completed INT;
BEGIN
    -- 1. Check if already completed to avoid redundant work.
    SELECT count(*)
    INTO already_completed
    FROM public.tb_livros_concluidos
    WHERE usuario_id = p_usuario_id AND plano_id = p_plano_id AND id_livro = p_livro_id;

    IF already_completed > 0 THEN
        RETURN;
    END IF;

    -- 2. Calculate the total number of chapters required by the plan for this book.
    SELECT count(DISTINCT caps.num)
    INTO target_chapters_count
    FROM public.tb_plano_entradas pe,
         LATERAL expand_capitulos(pe.capitulos) AS caps(num)
    WHERE pe.plano_id = p_plano_id AND pe.id_livro = p_livro_id;

    IF target_chapters_count = 0 THEN
        RETURN;
    END IF;

    -- 3. Count the distinct chapters read by the user for this book in this plan.
    SELECT count(DISTINCT l.capitulo)
    INTO read_chapters_count
    FROM public.tb_leituras l
    WHERE l.usuario_id = p_usuario_id AND l.plano_id = p_plano_id AND l.id_livro = p_livro_id;

    -- 4. If the user has read all required chapters, insert the completion record.
    IF read_chapters_count >= target_chapters_count THEN
        INSERT INTO public.tb_livros_concluidos (usuario_id, plano_id, id_livro)
        VALUES (p_usuario_id, p_plano_id, p_livro_id);
    END IF;
END;
$$;


CREATE OR REPLACE FUNCTION count_unique_readings_for_user(p_usuario_id integer)
RETURNS integer AS $$
DECLARE
    total_count integer;
BEGIN
    SELECT count(*)
    INTO total_count
    FROM (
        SELECT DISTINCT id_livro, capitulo
        FROM tb_leituras
        WHERE usuario_id = p_usuario_id
    ) as unique_readings;

    RETURN total_count;
END;
$$ LANGUAGE plpgsql;
